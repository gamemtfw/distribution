diff --git a/arch/arm64/boot/dts/rockchip/rk3566-evb2-lp4x-v10-linux.dts b/arch/arm64/boot/dts/rockchip/rk3566-evb2-lp4x-v10-linux.dts
index 1f3914977..634abe3be 100755
--- a/arch/arm64/boot/dts/rockchip/rk3566-evb2-lp4x-v10-linux.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-evb2-lp4x-v10-linux.dts
@@ -16,13 +16,14 @@
 #include "rk3568-android.dtsi"
 //#include "lcd/lcd_H546TAN01_720x1280_mipi_dsi0.dtsi"
 //#include "lcd/lcd_axs1832_auo55_720x1280_mipi_dsi0.dtsi"
-#include "lcd/lcd_HX8394F_720x1280_mipi_dsi0.dtsi"
+//#include "lcd/lcd_HX8394F_720x1280_mipi_dsi0.dtsi"
 / {
-	model = "Powkiddy x55";
+	model = "GameMT E6 Plus";
 	compatible = "rockchip,rk3566-rk817-tablet", "rockchip,rk3566";
-/*
+
 	adc_keys: adc-keys {
 		compatible = "adc-keys";
+		status = "okay";
 		io-channels = <&saradc 0>;
 		io-channel-names = "buttons";
 		keyup-threshold-microvolt = <1800000>;
@@ -39,74 +40,175 @@
 			linux,code = <KEY_VOLUMEDOWN>;
 			press-threshold-microvolt = <297500>;
 		};
-	};
-*/
 
-	zed_joystick {
-		compatible = "zed,joystick";
-		io-channels = <&saradc 0>,<&saradc 1>,<&saradc 2>, <&saradc 3>;
-		io-channel-names = "button0","button1","button2","button3";
-		keyup-threshold-microvolt = <1800000>;
-		poll-interval = <30>;
-		debounce-interval = <100>;	
-		pinctrl-names = "default";
-		pinctrl-0 = <&gpio_key_pin>;
-	//	pinctrl-0 = <&gpio_key_pin &vcc5v0_otg_en>;
-
-		//外置USB手柄应晚于板载摇杠初始化,否则会抢占默认手柄
-		otg-gpio = <&gpio4 RK_PC5 GPIO_ACTIVE_HIGH>;
-
-	//	gpio-key-num = <18>;
-		//映射的键值写在驱动里面了
-		key-gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_RIGHTSHOULDER
-			<&gpio3 RK_PC7 GPIO_ACTIVE_LOW>,//BTN_TR2
-			<&gpio3 RK_PD0 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_LEFTSHOULDER
-			<&gpio3 RK_PD1 GPIO_ACTIVE_LOW>,//BTN_TL2
-			<&gpio3 RK_PD2 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_A
-			<&gpio3 RK_PD3 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_B
-			<&gpio3 RK_PD4 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_X
-			<&gpio3 RK_PD5 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_Y
-			<&gpio3 RK_PD6 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_DPAD_LEFT
-			<&gpio3 RK_PD7 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_DPAD_RIGHT
-			<&gpio4 RK_PA0 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_DPAD_UP
-			<&gpio4 RK_PA1 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_DPAD_DOWN
-			<&gpio4 RK_PA2 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_BACK(select)
-			<&gpio4 RK_PA3 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_START
-			<&gpio4 RK_PA4 GPIO_ACTIVE_LOW>,//KEY_VOLUMEUP
-			<&gpio4 RK_PA5 GPIO_ACTIVE_LOW>,//KEY_VOLUMEDOWN
-			<&gpio4 RK_PA7 GPIO_ACTIVE_LOW>,//SDL_CONTROLLER_BUTTON_LEFTSTICK
-			<&gpio4 RK_PB0 GPIO_ACTIVE_LOW>;//SDL_CONTROLLER_BUTTON_RIGHTSTICK
-
-
-		left-x {
-			label = "left x";
-			adc-chan = <0>;
-			linux,code = <ABS_X>;
-			press-threshold-microvolt = <1750>;
+		esc-key {
+			linux,code = <KEY_ESC>;
+			label = "esc";
+			press-threshold-microvolt = <824000>;
 		};
 
-		left-y {
-			label = "left y";
-			adc-chan = <1>;
-			linux,code = <ABS_Y>;
-			press-threshold-microvolt = <1750>;
+		select-key {
+			linux,code = <KEY_RIGHTSHIFT>;
+			label = "select";
+			press-threshold-microvolt = <1218000>;
 		};
 
-		right-x {
-			label = "right x";
-			adc-chan = <2>;
-			linux,code = <ABS_RX>;
-			press-threshold-microvolt = <1750>;
+		start-key {
+			linux,code = <KEY_ENTER>;
+			label = "start";
+			press-threshold-microvolt = <1516000>;
 		};
+	};
 
-		right-y {
-			label = "right y";
-			adc-chan = <3>;
-			linux,code = <ABS_RY>;
-			press-threshold-microvolt = <1750>;
+	joypad: singleadc-joypad {
+		compatible = "singleadc-joypad";
+
+		joypad-name = "retrogame_joypad";
+		joypad-product = <0x1101>;
+		joypad-revision = <0x0100>;
+
+		status = "okay";
+
+		/* gpio pincontrol setup */
+		pinctrl-names = "default";
+		pinctrl-0 = <&btn_pins>;
+
+		/* Analog mux define */
+		io-channel-names = "amux_adc";
+		io-channels = <&saradc 3>;
+
+		/* adc mux channel count */
+		amux-count = <4>;
+		/* adc mux select(a,b) gpio */
+		amux-a-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_LOW>;
+		amux-b-gpios = <&gpio4 RK_PB5 GPIO_ACTIVE_LOW>;
+		/* adc mux enable gpio */
+		amux-en-gpios = <&gpio4 RK_PB7 GPIO_ACTIVE_LOW>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <450>;
+		abs_x-n-tuning = <450>;
+
+		abs_y-p-tuning = <450>;
+		abs_y-n-tuning = <450>;
+
+		abs_rx-p-tuning = <450>;
+		abs_rx-n-tuning = <450>;
+
+		abs_ry-p-tuning = <450>;
+		abs_ry-n-tuning = <450>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+		sw1 {
+			gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-UP"; //B
+			linux,code = <BTN_DPAD_UP>;
 		};
-        };  
-	
+		sw2 {
+			gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-DOWN";//dpad_right
+			linux,code = <BTN_DPAD_DOWN>;
+		};
+		sw3 {
+			gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-LEFT";//left_joystick
+			linux,code = <BTN_DPAD_LEFT>;
+		};
+		sw4 {
+			gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-RIGHT";//right_joystick
+			linux,code = <BTN_DPAD_RIGHT>;
+		};
+		sw5 {
+			gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-A";//x
+			linux,code = <BTN_SOUTH>;
+		};
+		sw6 {
+			gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-B";//A
+			linux,code = <BTN_EAST>;
+		};
+		
+		sw7 {
+			gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-X";//y
+			linux,code = <BTN_NORTH>;
+		};
+		sw8 {
+			gpios = <&gpio4 RK_PB0 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-Y";//dpad_left
+			linux,code = <BTN_WEST>;
+		};
+		sw9 {
+			gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_SELECT";
+			linux,code = <BTN_SELECT>;
+		};
+		sw10 {
+			gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_START";
+			linux,code = <BTN_START>;
+		};
+		sw11 {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_F";
+			linux,code = <BTN_MODE>;
+		};
+		sw12 {
+			gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL";//ok
+			linux,code = <BTN_TL>;
+		};
+		sw13 {
+			gpios = <&gpio4 RK_PA4 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR2"; //BTN_TL2
+			linux,code = <BTN_TR2>;
+		};
+		sw14 {
+			gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL2";//BTN_TR
+			linux,code = <BTN_TL2>;
+		};
+		sw15 {
+			gpios = <&gpio4 RK_PA3 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR";//BTN_TR2
+			linux,code = <BTN_TR>;
+		};
+		sw16 {
+			gpios = <&gpio4 RK_PC0 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_THUMBL";//dpad_up
+			linux,code = <BTN_THUMBL>;
+		};
+		sw17 {
+			gpios = <&gpio4 RK_PC1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_THUMBR";//dpad_down
+			linux,code = <BTN_THUMBR>;
+		};
+	};
 
 	backlight: backlight {
 		compatible = "pwm-backlight";
@@ -150,7 +252,7 @@
 
 	charge-animation {
 		compatible = "rockchip,uboot-charge";
-		rockchip,uboot-charge-on = <1>;
+		rockchip,uboot-charge-on = <0>;
 		rockchip,android-charge-on = <0>;
 		rockchip,uboot-low-power-voltage = <3350>;
 		rockchip,screen-on-voltage = <3400>;
@@ -158,7 +260,7 @@
 	};
 
 	flash_rgb13h: flash-rgb13h {
-		status = "okay";
+		status = "disabled";
 		compatible = "led,rgb13h";
 		label = "gpio-flash";
 		pinctrl-names = "default";
@@ -171,26 +273,6 @@
 		rockchip,camera-module-facing = "back";
 	};
 
-	vcc5v0_otg: vcc5v0-otg-regulator {
-		compatible = "regulator-fixed";
-		enable-active-high;
-		gpio = <&gpio4 RK_PC5 GPIO_ACTIVE_HIGH>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&vcc5v0_otg_en>;
-		regulator-name = "vcc5v0_otg";
-	};
-
-	vcc5v0_host: vcc5v0-host-regulator {
-		compatible = "regulator-fixed";
-		enable-active-high;
-		gpio = <&gpio4 RK_PC4 GPIO_ACTIVE_HIGH>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&vcc5v0_host_en>;
-		regulator-name = "vcc5v0_host";
-		regulator-always-on;
-		regulator-boot-on;
-	};
-
 	rk817-sound {
 		compatible = "simple-audio-card";
 		simple-audio-card,format = "i2s";
@@ -280,6 +362,32 @@
 			3300000 0x1>;
 	};
 
+	leds: gpio-leds {
+                compatible = "gpio-leds";
+                pinctrl-names = "default";
+                pinctrl-0 =<&leds_gpio>;
+
+				left_joystick {
+					gpios = <&gpio4 RK_PC4 GPIO_ACTIVE_HIGH>;
+					default-state="on";
+                };
+
+                right_joystick {
+					gpios = <&gpio4 RK_PC5 GPIO_ACTIVE_HIGH>;
+					default-state="on";
+                };
+				
+                left_below {
+					gpios = <&gpio0 RK_PC2 GPIO_ACTIVE_HIGH>;
+					default-state="on";
+                };
+
+				right_below {
+					gpios = <&gpio4 RK_PC3 GPIO_ACTIVE_HIGH>;
+					default-state="on";
+                };			
+	};
+
 	wireless-wlan {
 		compatible = "wlan-platdata";
 		rockchip,grf = <&grf>;
@@ -359,14 +467,244 @@
 
 &dsi0 {
 	status = "okay";
-	dsi0_panel: panel@0 {
+	//	rockchip,dual-channel = <&dsi1>;
+	
+	//rockchip,lane-rate = <1000>;
+ 	dsi0_panel: panel@0 {
+		compatible ="simple-panel-dsi";
+		reg = <0>;
+		reset-delay-ms = <60>;
+		enable-delay-ms = <120>;
+		prepare-delay-ms = <60>;
+		init-delay-ms = <60>;
+		unprepare-delay-ms = <60>;
+		disable-delay-ms = <60>;
+		
 		backlight = <&backlight>;
 	//	power_vsx-gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
 		enable-gpios = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
-		reset-gpios = <&gpio0 RK_PD5 GPIO_ACTIVE_LOW>;
-	//	pinctrl-names = "default";
-	//	pinctrl-0 = <&lcd0_rst_gpio>;
+		reset-gpios = <&gpio0 RK_PA6 GPIO_ACTIVE_LOW>;
+
+		rotation = <270>;
+
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes  = <4>;
+		panel-init-sequence = [
+			39 00 04 FF 98 81 07
+			15 00 02 03 20
+			15 00 02 04 06
+			15 00 02 05 00
+			15 00 02 06 01
+			15 00 02 07 00
+			15 00 02 08 00
+			15 00 02 09 00
+			15 00 02 0A 00
+			15 00 02 0B 2F
+			15 00 02 0C 00
+			15 00 02 0D 00
+			15 00 02 0E 00
+			15 00 02 0F 00
+			15 00 02 10 40
+			15 00 02 11 02
+			15 00 02 12 05
+			15 00 02 13 00
+			15 00 02 14 00
+			15 00 02 15 00
+			15 00 02 16 2F
+			15 00 02 17 2F
+			15 00 02 18 00
+			15 00 02 19 00
+			15 00 02 1A 00
+			15 00 02 1B 50
+			15 00 02 1C BC
+			15 00 02 1D 0C
+			15 00 02 1E 00
+			15 00 02 1F 00
+			15 00 02 20 00
+			15 00 02 21 00
+			15 00 02 22 00
+			15 00 02 23 C0
+			15 00 02 24 30
+			15 00 02 25 00
+			15 00 02 26 00
+			15 00 02 27 03
+			15 00 02 30 01
+			15 00 02 31 23
+			15 00 02 32 45
+			15 00 02 33 67
+			15 00 02 34 89
+			15 00 02 35 AB
+			15 00 02 36 01
+			15 00 02 37 23
+			15 00 02 38 45
+			15 00 02 39 67
+			15 00 02 3A 89
+			15 00 02 3B AB
+			15 00 02 3C CD
+			15 00 02 3D EF
+			15 00 02 50 11
+			15 00 02 51 06
+			15 00 02 52 0C
+			15 00 02 53 0D
+			15 00 02 54 0E
+			15 00 02 55 0F
+			15 00 02 56 02
+			15 00 02 57 02
+			15 00 02 58 02
+			15 00 02 59 02
+			15 00 02 5A 02
+			15 00 02 5B 02
+			15 00 02 5C 02
+			15 00 02 5D 02
+			15 00 02 5E 02
+			15 00 02 5F 02
+			15 00 02 60 05
+			15 00 02 61 05
+			15 00 02 62 05
+			15 00 02 63 02
+			15 00 02 64 01
+			15 00 02 65 00
+			15 00 02 66 08
+			15 00 02 67 08
+			15 00 02 68 0C
+			15 00 02 69 0D
+			15 00 02 6A 0E
+			15 00 02 6B 0F
+			15 00 02 6C 02
+			15 00 02 6D 02
+			15 00 02 6E 02
+			15 00 02 6F 02
+			15 00 02 70 02
+			15 00 02 71 02
+			15 00 02 72 02
+			15 00 02 73 02
+			15 00 02 74 02
+			15 00 02 75 02
+			15 00 02 76 05
+			15 00 02 77 05
+			15 00 02 78 05
+			15 00 02 79 02
+			15 00 02 7A 01
+			15 00 02 7B 00
+			15 00 02 7C 06
+			39 00 04 FF 98 81 08
+			15 00 02 76 B4
+			15 00 02 78 02
+			15 00 02 74 2B
+			15 00 02 8E 15
+			15 00 02 40 01
+			15 00 02 84 81
+			15 00 02 72 25
+			15 00 02 E3 75
+			15 00 02 7D CB
+			15 00 02 7E 49
+			15 00 02 49 10
+			15 00 02 32 05
+			15 00 02 3C 05
+			39 00 04 FF 98 81 01
+			15 00 02 22 0A
+			15 00 02 43 01
+			15 00 02 53 82
+			15 00 02 55 85
+			15 00 02 50 B9
+			15 00 02 51 BA
+			15 00 02 31 00
+			15 00 02 A0 00
+			15 00 02 A1 14
+			15 00 02 A2 2B
+			15 00 02 A3 16
+			15 00 02 A4 1C
+			15 00 02 A5 2E
+			15 00 02 A6 18
+			15 00 02 A7 20
+			15 00 02 A8 78
+			15 00 02 A9 20
+			15 00 02 AA 2A
+			15 00 02 AB 83
+			15 00 02 AC 25
+			15 00 02 AD 1B
+			15 00 02 AE 54
+			15 00 02 AF 2B
+			15 00 02 B0 2B
+			15 00 02 B1 4F
+			15 00 02 B2 67
+			15 00 02 B3 39
+			15 00 02 C0 00
+			15 00 02 C1 14
+			15 00 02 C2 2B
+			15 00 02 C3 16
+			15 00 02 C4 1C
+			15 00 02 C5 2E
+			15 00 02 C6 18
+			15 00 02 C7 20
+			15 00 02 C8 78
+			15 00 02 C9 20
+			15 00 02 CA 2A
+			15 00 02 CB 83
+			15 00 02 CC 25
+			15 00 02 CD 1B
+			15 00 02 CE 54
+			15 00 02 CF 2B
+			15 00 02 D0 2B
+			15 00 02 D1 4F
+			15 00 02 D2 67
+			15 00 02 D3 39
+			39 00 04 FF 98 81 00
+			05 78 01 11
+			05 14 01 29
+		];
+
+		panel-exit-sequence = [
+			05 10 01 28
+			05 20 01 10
+		];
+
+		disp_timings0: display-timings {
+			native-mode = <&dsi0_timing0>;
+			dsi0_timing0: timing0 {
+				clock-frequency = <66000000>;
+				hactive = <720>;
+				vactive = <1280>;
+				hfront-porch = <50>;
+				hsync-len = <20>;
+				hback-porch = <50>;
+				vfront-porch = <10>;
+				vsync-len = <4>;
+				vback-porch = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+				};
+			};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi: endpoint {
+					remote-endpoint = <&dsi_out_panel>;
+				};
+			};
+		};
 	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+
 };
 
 &dsi0_in_vp0 {
@@ -707,9 +1045,9 @@
 			sample_res = <10>;
 			virtual_power = <0>;
 		//	dc_det_gpio = <&gpio4 RK_PC4 GPIO_ACTIVE_HIGH>;//uboot使用
-			charge_red_gpio = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;//充电指示灯 红
-			charge_green_gpio = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;//充电指示灯 绿
-			charge_yellow_gpio = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;//充电指示灯 黄   
+			charge_red_gpio = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			charge_green_gpio = <&gpio3 RK_PC2 GPIO_ACTIVE_HIGH>;
+			charge_yellow_gpio = <&gpio3 RK_PC3 GPIO_ACTIVE_HIGH>;
 		};
 
 		charger {
@@ -723,9 +1061,9 @@
 			virtual_power = <0>;
 			dc_det_adc = <0>;
 		//	dc_det_gpio = <&gpio4 RK_PC4 GPIO_ACTIVE_HIGH>;
-			charge_red_gpio = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;//充电指示灯 红
-			charge_green_gpio = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;//充电指示灯 绿
-			charge_yellow_gpio = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;//充电指示灯 黄   
+			charge_red_gpio = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			charge_green_gpio = <&gpio3 RK_PC2 GPIO_ACTIVE_HIGH>;
+			charge_yellow_gpio = <&gpio3 RK_PC3 GPIO_ACTIVE_HIGH>; 
 			pinctrl-names = "default";
 			pinctrl-0 = <&charge_led_gpio>;
 			extcon = <&usb2phy0>;
@@ -917,43 +1255,45 @@
 			rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
-	usb {
-         vcc5v0_host_en: vcc5v0-host-en {
-                 rockchip,pins = <4 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
-         };
-
-         vcc5v0_otg_en: vcc5v0-otg-en {
-                 rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_up>;
-         };
+
+	gpio-leds {
+		leds_gpio: leds-gpio {
+			rockchip,pins =
+				<0 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<4 RK_PC3 RK_FUNC_GPIO &pcfg_pull_none>,
+				<4 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>,
+				<4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
 	};
+
 	led {
 		charge_led_gpio:charge-led-gpio{
-                 rockchip,pins = <4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_none>,
-                 		 <4 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>,
-                                 <4 RK_PB6 RK_FUNC_GPIO &pcfg_pull_none>;
+                 rockchip,pins = <3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>,
+                 		 <3 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>,
+                                 <3 RK_PC3 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	
 	};
-	buttons {
-		gpio_key_pin: gpio-key-pin {
-			rockchip,pins = <3 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD0 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD1 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD4 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD6 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <3 RK_PD7 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
-			                <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+	btns {
+		btn_pins: btn-pins {
+			rockchip,pins = 
+					<4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PC0 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PB3 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<4 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>;
 		};
 	};
 };
@@ -1112,13 +1452,11 @@
 };
 
 &u2phy0_otg {
-	vbus-supply = <&vcc5v0_otg>;
 	status = "okay";
 };
 
 &u2phy0_host {
 	status = "okay";
-	phy-supply = <&vcc5v0_host>;
 };
 
 &combphy1_usq {
diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index 753043d2c..c642816dd 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -363,4 +363,9 @@ config JOYSTICK_PXRC
 
 config JOYSTICK_ZED
 	tristate "zed board joystick"
+
+config JOYSTICK_SINGLEADCJOY
+	tristate "Single SARADC dual-joystick gamepad driver"
+	help
+	  The 1-in 4-out SARADC joypad driver.
 endif
diff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile
index e52973873..24353978f 100644
--- a/drivers/input/joystick/Makefile
+++ b/drivers/input/joystick/Makefile
@@ -36,4 +36,4 @@ obj-$(CONFIG_JOYSTICK_XPAD)		+= xpad.o
 obj-$(CONFIG_JOYSTICK_ZHENHUA)		+= zhenhua.o
 obj-$(CONFIG_JOYSTICK_WALKERA0701)	+= walkera0701.o
 obj-$(CONFIG_JOYSTICK_ZED)	+= zed_joystick.o
-
+obj-$(CONFIG_JOYSTICK_SINGLEADCJOY)	+= singleadcjoy.o
\ No newline at end of file
diff --git a/drivers/input/joystick/singleadcjoy.c b/drivers/input/joystick/singleadcjoy.c
new file mode 100644
index 000000000..9db72178d
--- /dev/null
+++ b/drivers/input/joystick/singleadcjoy.c
@@ -0,0 +1,1162 @@
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Copyright (c) 2008-2021 Anbernic 
+ */
+
+/*
+ * Single SARADC dual-joystick gamepad driver
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "retrogame_joypad"
+#define __MURMUR__
+/*----------------------------------------------------------------------------*/
+#define	ADC_MAX_VOLTAGE		1800
+#define	ADC_DATA_TUNING(x, p)	((x * p) / 100)
+#define	ADC_TUNING_DEFAULT	180
+
+struct bt_adc {
+	/* report value (mV) */
+	int value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+	/* amux channel */
+	int amux_ch;
+	/* adc data tuning value([percent), p = positive, n = negative */
+	int tuning_p, tuning_n;
+};
+
+struct analog_mux {
+	/* IIO ADC Channel : amux connect channel */
+	struct iio_channel *iio_ch;
+	/* analog mux select(a,b) gpio */
+	int sel_a_gpio, sel_b_gpio;
+	/* analog mux enable gpio */
+	int en_gpio;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* analog mux & joystick control */
+	struct analog_mux *amux;
+	/* analog mux max count */
+	int amux_count;
+	/* analog button */
+	struct bt_adc *adcs;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+
+	struct mutex lock;
+
+	/* amux debug channel */
+	int debug_ch;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int button_adc_fuzz(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static int joypad_amux_select(struct analog_mux *amux, int channel)
+{
+	/* select mux channel */
+	gpio_set_value(amux->en_gpio, 0);
+
+	switch(channel) {
+		case 0:	/* EVENT (ABS_RY) */
+			gpio_set_value(amux->sel_a_gpio, 0);
+			gpio_set_value(amux->sel_b_gpio, 0);
+			break;
+		case 1:	/* EVENT (ABS_RX) */
+			gpio_set_value(amux->sel_a_gpio, 0);
+			gpio_set_value(amux->sel_b_gpio, 1);
+			break;
+		case 2:	/* EVENT (ABS_Y) */
+			gpio_set_value(amux->sel_a_gpio, 1);
+			gpio_set_value(amux->sel_b_gpio, 0);
+			break;
+		case 3:	/* EVENT (ABS_X) */
+			gpio_set_value(amux->sel_a_gpio, 1);
+			gpio_set_value(amux->sel_b_gpio, 1);
+			break;
+		default:
+			/* amux disanle */
+			gpio_set_value(amux->en_gpio, 1);
+			return -1;
+	}
+	/* mux swtiching speed : 35ns(on) / 9ns(off) */
+	usleep_range(10, 20);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct analog_mux *amux, struct bt_adc *adc)
+{
+	int value;
+
+
+	if (joypad_amux_select(amux, adc->amux_ch))
+		return 0;
+
+	iio_read_channel_raw(amux->iio_ch, &value);
+
+	value *= adc->scale;
+#ifdef __LEFT_JOYSTICK_INVERT__
+	return value;
+#else
+	return (adc->invert ? (adc->max - value) : value);
+#endif
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/retrogame_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/retrogame_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/retrogame_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/retrogame_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/retrogame_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->value = joypad_adc_read(joypad->amux, adc);
+			if (!adc->value) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->cal = adc->value;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d\n",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "adc scale = %d\n", joypad->bt_adc_scale);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/retrogame_joypad/amux_debug [rw]
+ *
+ * echo [debug channel] > amux_debug
+ * cat amux_debug : debug channel mux set & adc read
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_amux_debug(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	joypad->debug_ch = simple_strtoul(buf, NULL, 10);
+
+	/* if error than default setting(debug_ch = 0) */
+	if (joypad->debug_ch > joypad->amux_count)
+		joypad->debug_ch = 0;
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_amux_debug(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	struct analog_mux *amux = joypad->amux;
+	ssize_t pos;
+	int value;
+
+	mutex_lock(&joypad->lock);
+
+	/* disable poll driver */
+	if (joypad->enable)
+		joypad->enable = false;
+
+	if (joypad_amux_select(amux, joypad->debug_ch))
+		goto err_out;
+
+	if (iio_read_channel_processed(amux->iio_ch, &value))
+		goto err_out;
+
+	pos = sprintf(buf, "amux ch[%d], adc scale = %d, adc value = %d\n",
+			joypad->debug_ch, joypad->bt_adc_scale,
+			value * joypad->bt_adc_scale);
+	goto out;
+
+err_out:
+	pos = sprintf(buf, "error : amux setup & adc read!\n");
+out:
+	mutex_unlock(&joypad->lock);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(amux_debug, S_IWUSR | S_IRUGO,
+		   joypad_show_amux_debug,
+		   joypad_store_amux_debug);
+
+/*----------------------------------------------------------------------------*/
+#ifdef __MURMUR__
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/bus/platform/devices/singleadc-joypad/vol [rw]
+ *
+ * echo [debug channel] > vol
+ * cat vol : debug channel mux set & adc read
+ */
+/*----------------------------------------------------------------------------*/
+
+extern int rk817_hp_inserted;
+
+int rk817_pa_power_on=1;
+EXPORT_SYMBOL(rk817_pa_power_on);
+
+int vol_temp=100;
+
+static ssize_t joypad_store_vol(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{	
+
+	vol_temp = simple_strtoul(buf, NULL, 10);
+
+	if(vol_temp>=15){
+		rk817_pa_power_on=1;
+		if(rk817_hp_inserted==0){
+			gpio_direction_output(146,1);	
+		}
+		
+	}else{
+		rk817_pa_power_on=0;
+
+		if(rk817_hp_inserted==0){
+			gpio_direction_output(146,0);	
+		}
+	}
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_vol(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	ssize_t pos;
+	pos = sprintf(buf, "%d\n",vol_temp);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(vol, S_IWUSR | S_IRUGO,joypad_show_vol, joypad_store_vol);
+
+/*----------------------------------------------------------------------------*/
+#endif
+#ifdef __MURMUR__
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	&dev_attr_amux_debug.attr,
+	&dev_attr_vol.attr,
+	NULL,
+};
+#else
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	&dev_attr_amux_debug.attr,
+	NULL,
+};
+#endif
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad->amux, adc);
+		if (!adc->value) {
+			//dev_err(joypad->dev, "%s : saradc channels[%d]! adc->value : %d\n",__func__, nbtn, adc->value);
+			continue;
+		}
+		adc->value = adc->value - adc->cal;
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if (adc->value > joypad->bt_adc_deadzone)
+				adc->value -= joypad->bt_adc_deadzone;
+			else if (adc->value < -joypad->bt_adc_deadzone)
+				adc->value += joypad->bt_adc_deadzone;
+			else adc->value = 0;
+		}
+		
+		adc->value = abs(adc->value) < 16 ? 0 : adc->value;
+
+		/* adc data tuning */
+		if (adc->tuning_n && adc->value < 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_n);
+		if (adc->tuning_p && adc->value > 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_p);
+
+		adc->value = adc->value > adc->max ? adc->max : adc->value;
+		adc->value = adc->value < adc->min ? adc->min : adc->value;
+
+		input_report_abs(poll_dev->input,
+			adc->report_type,
+			adc->invert ? adc->value * (-1) : adc->value);
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad->amux, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_amux_setup(struct device *dev, struct joypad *joypad)
+{
+	struct analog_mux *amux;
+	enum iio_chan_type type;
+	enum of_gpio_flags flags;
+	int ret;
+
+	/* analog mux control struct init */
+	joypad->amux = devm_kzalloc(dev, sizeof(struct analog_mux),
+					GFP_KERNEL);
+	if (!joypad->amux) {
+		dev_err(dev, "%s amux devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+	amux = joypad->amux;
+	amux->iio_ch = devm_iio_channel_get(dev, "amux_adc");
+	if (IS_ERR(amux->iio_ch)) {
+		dev_err(dev, "iio channel get error\n");
+		return -EINVAL;
+	}
+	if (!amux->iio_ch->indio_dev)
+		return -ENXIO;
+
+	if (iio_get_channel_type(amux->iio_ch, &type))
+		return -EINVAL;
+
+	if (type != IIO_VOLTAGE) {
+		dev_err(dev, "Incompatible channel type %d\n", type);
+		return -EINVAL;
+	}
+
+	amux->sel_a_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-a-gpios", 0, &flags);
+	if (gpio_is_valid(amux->sel_a_gpio)) {
+		ret = devm_gpio_request(dev, amux->sel_a_gpio, "amux-sel-a");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-sel-a %d\n",
+				__func__, amux->sel_a_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->sel_a_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+
+	amux->sel_b_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-b-gpios", 0, &flags);
+	if (gpio_is_valid(amux->sel_b_gpio)) {
+		ret = devm_gpio_request(dev, amux->sel_b_gpio, "amux-sel-b");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-sel-b %d\n",
+				__func__, amux->sel_b_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->sel_b_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+
+	amux->en_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-en-gpios", 0, &flags);
+	if (gpio_is_valid(amux->en_gpio)) {
+		ret = devm_gpio_request(dev, amux->en_gpio, "amux-en");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-en %d\n",
+				__func__, amux->en_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->en_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+	return	0;
+err_out:
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn;
+
+	/* adc button struct init */
+	joypad->adcs = devm_kzalloc(dev, joypad->amux_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->scale = joypad->bt_adc_scale;
+		
+		adc->max = (ADC_MAX_VOLTAGE / 2);
+		adc->min = (ADC_MAX_VOLTAGE / 2) * (-1);
+		if (adc->scale) {
+			adc->max *= adc->scale;
+			adc->min *= adc->scale;
+		}
+		adc->amux_ch = nbtn;
+		adc->invert = false;
+
+		switch (nbtn) {
+			case 0:
+				adc->report_type = ABS_RY;
+				if (device_property_read_u32(dev,
+					"abs_ry-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_ry-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 1:
+				adc->report_type = ABS_RX;
+				if (device_property_read_u32(dev,
+					"abs_rx-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_rx-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 2:
+			#ifdef __LEFT_JOYSTICK_INVERT__
+				adc->invert = true;	
+			#endif
+				adc->report_type = ABS_Y;
+				if (device_property_read_u32(dev,
+					"abs_y-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_y-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 3:
+			#ifdef __LEFT_JOYSTICK_INVERT__
+				adc->invert = true;	
+			#endif
+				adc->report_type = ABS_X;
+				if (device_property_read_u32(dev,
+					"abs_x-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_x-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			default :
+				dev_err(dev, "%s amux count(%d) error!",
+					__func__, nbtn);
+				return -EINVAL;
+		}
+	}
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+struct input_dev * joypad_input_g;
+
+
+void rk_send_key_f_key_up(void)
+{
+	if (!joypad_input_g)
+		return;
+
+	input_report_key(joypad_input_g, BTN_MODE, 1);
+	input_sync(joypad_input_g);
+}
+EXPORT_SYMBOL(rk_send_key_f_key_up);
+
+
+void rk_send_key_f_key_down(void)
+{
+	if (!joypad_input_g)
+		return;
+
+	input_report_key(joypad_input_g, BTN_MODE, 0);
+	input_sync(joypad_input_g);
+}
+EXPORT_SYMBOL(rk_send_key_f_key_down);
+
+
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+	u32 joypad_revision = 0;
+	u32 joypad_product = 0;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+	joypad_input_g=input;
+
+	device_property_read_string(dev, "joypad-name", &input->name);
+	input->phys = DRV_NAME"/input0";
+
+	device_property_read_u32(dev, "joypad-revision", &joypad_revision);
+	device_property_read_u32(dev, "joypad-product", &joypad_product);
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x484B;
+	input->id.product = (u16)joypad_product;
+	input->id.version = (u16)joypad_revision;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+		dev_info(dev,
+			"%s : adc tuning_p = %d, adc_tuning_n = %d\n\n",
+			__func__, adc->tuning_p, adc->tuning_n);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	joypad->dev = dev;
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	device_property_read_u32(dev, "amux-count",
+				&joypad->amux_count);
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->amux_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->amux_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_amux_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	dev_info(dev, "%s : adc key cnt = %d, gpio key cnt = %d\n",
+			__func__, joypad->amux_count, joypad->bt_gpio_count);
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "singleadc-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
diff --git a/sound/soc/codecs/rk817_codec.c b/sound/soc/codecs/rk817_codec.c
index a7b4feff2..c554d7e9b 100755
--- a/sound/soc/codecs/rk817_codec.c
+++ b/sound/soc/codecs/rk817_codec.c
@@ -25,12 +25,17 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include "rk817_codec.h"
-
-#ifdef CONFIG_SND_DEBUG
-#define DBG(args...) pr_info(args)
-#else
-#define DBG(args...)
-#endif
+#define __MURMUR__
+#define CONFIG_RK817_HEADSET
+static int dbg_enable;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
 
 /* For route */
 #define RK817_CODEC_PLAYBACK	1
@@ -61,7 +66,39 @@
 
 #define CODEC_SET_SPK 1
 #define CODEC_SET_HP 2
+#if defined(CONFIG_RK817_HEADSET)
+struct rk817_codec_priv {
+	struct snd_soc_component *component;
+	struct regmap *regmap;
+	struct rk808 *rk817;
+	struct clk *mclk;
+
+	unsigned int stereo_sysclk;
+	unsigned int rate;
 
+	unsigned int spk_volume;
+	unsigned int hp_volume;
+	unsigned int capture_volume;
+
+	bool mic_in_differential;
+	bool pdmdata_out_enable;
+	bool use_ext_amplifier;
+	bool adc_for_loopback;
+
+	bool out_l2spk_r2hp;
+	long int playback_path;
+	long int capture_path;
+
+	struct gpio_desc *spk_ctl_gpio;
+	struct gpio_desc *hp_ctl_gpio;
+	
+	bool hp_inserted;
+	
+	int spk_mute_delay;
+	int hp_mute_delay;
+};
+struct rk817_codec_priv *rk817_g;
+#else
 struct rk817_codec_priv {
 	struct snd_soc_component *component;
 	struct regmap *regmap;
@@ -83,13 +120,14 @@ struct rk817_codec_priv {
 	bool out_l2spk_r2hp;
 	long int playback_path;
 	long int capture_path;
-	long int mute;
 
 	struct gpio_desc *spk_ctl_gpio;
 	struct gpio_desc *hp_ctl_gpio;
+	
 	int spk_mute_delay;
 	int hp_mute_delay;
 };
+#endif
 
 static const struct reg_default rk817_reg_defaults[] = {
 	{ RK817_CODEC_DTOP_VUCTL, 0x003 },
@@ -224,13 +262,22 @@ static bool rk817_codec_register(struct device *dev, unsigned int reg)
 		return false;
 	}
 }
-
+#ifdef __MURMUR__
+extern int rk817_pa_power_on;
+#endif
 static int rk817_codec_ctl_gpio(struct rk817_codec_priv *rk817,
 				int gpio, int level)
 {
 	if ((gpio & CODEC_SET_SPK) &&
 	    rk817->spk_ctl_gpio) {
-		gpiod_set_value(rk817->spk_ctl_gpio, level);
+		#ifdef __MURMUR__
+		if(rk817_pa_power_on==1)
+		{
+			gpiod_set_value(rk817->spk_ctl_gpio, level);
+		}
+		#else
+			gpiod_set_value(rk817->spk_ctl_gpio, level);
+		#endif
 		DBG("%s set spk clt %d\n", __func__, level);
 		msleep(rk817->spk_mute_delay);
 	}
@@ -472,9 +519,6 @@ static const char * const rk817_playback_path_mode[] = {
 
 static const char * const rk817_capture_path_mode[] = {
 	"MIC OFF", "Main Mic", "Hands Free Mic", "BT Sco Mic"};
-	
-static const char * const rk817_mute_mode[] = {
-	"UNMUTE", "MUTE"};	
 
 static const char * const rk817_call_path_mode[] = {
 	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT"}; /* 0-5 */
@@ -487,10 +531,6 @@ static SOC_ENUM_SINGLE_DECL(rk817_playback_path_type,
 static SOC_ENUM_SINGLE_DECL(rk817_capture_path_type,
 	0, 0, rk817_capture_path_mode);
 
-static SOC_ENUM_SINGLE_DECL(rk817_mute_type,
-	0, 0, rk817_mute_mode);
-	
-	
 static SOC_ENUM_SINGLE_DECL(rk817_call_path_type,
 	0, 0, rk817_call_path_mode);
 
@@ -813,125 +853,12 @@ static int rk817_capture_path_put(struct snd_kcontrol *kcontrol,
 					 ucontrol->value.integer.value[0]);
 }
 
-
-
-static int rk817_mute_config(struct snd_soc_component *component,
-				     long pre_mute, long target_mute)
-{
-	
-	struct rk817_codec_priv *rk817 = snd_soc_component_get_drvdata(component);
-
-	rk817->mute = target_mute;
-
-	DBG("%s : set mute %ld, pre_mute %ld\n", __func__,
-	    rk817->mute, pre_mute);
-
-	if (rk817->mute) {
-		rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
-		rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 0);
-
-		snd_soc_component_update_bits(component,
-					      RK817_CODEC_DDAC_MUTE_MIXCTL,
-					      DACMT_ENABLE, DACMT_ENABLE);
-		snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
-					PWD_DACBIAS_DOWN | PWD_DACD_DOWN |
-					PWD_DACL_DOWN | PWD_DACR_DOWN);
-		/* Reset DAC DTOP_DIGEN_CLKE for playback stopped */
-		snd_soc_component_update_bits(component, RK817_CODEC_DTOP_DIGEN_CLKE,
-					      DAC_DIG_CLK_EN, DAC_DIG_CLK_DIS);
-		snd_soc_component_update_bits(component, RK817_CODEC_DTOP_DIGEN_CLKE,
-					      DAC_DIG_CLK_EN, DAC_DIG_CLK_EN);
-	} else {
-		snd_soc_component_update_bits(component,
-					      RK817_CODEC_DDAC_MUTE_MIXCTL,
-					      DACMT_ENABLE, DACMT_DISABLE);
-
-		switch (rk817->playback_path) {
-		case SPK_PATH:
-		case RING_SPK:
-			if (rk817->out_l2spk_r2hp) {
-				snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
-						PWD_DACBIAS_ON | PWD_DACD_ON |
-						PWD_DACL_ON | PWD_DACR_ON);
-			} else if (!rk817->use_ext_amplifier) {
-				snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
-						PWD_DACBIAS_ON | PWD_DACD_ON |
-						PWD_DACL_DOWN | PWD_DACR_DOWN);
-			} else {
-				snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
-						PWD_DACBIAS_ON | PWD_DACD_DOWN |
-						PWD_DACL_ON | PWD_DACR_ON);
-			}
-			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
-			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 0);
-			break;
-		case HP_PATH:
-		case HP_NO_MIC:
-		case RING_HP:
-		case RING_HP_NO_MIC:
-			snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
-					PWD_DACBIAS_ON | PWD_DACD_DOWN |
-					PWD_DACL_ON | PWD_DACR_ON);
-			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
-			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
-			break;
-		case SPK_HP:
-		case RING_SPK_HP:
-			snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
-					PWD_DACBIAS_ON | PWD_DACD_ON |
-					PWD_DACL_ON | PWD_DACR_ON);
-			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
-			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
-			break;
-		default:
-			break;
-		}
-	}
-
-	return 0;
-}
-
-static int rk817_mute_get(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk817_codec_priv *rk817 = snd_soc_component_get_drvdata(component);
-
-	DBG("%s : mute %ld\n", __func__,
-	    rk817->mute);
-
-	ucontrol->value.integer.value[0] = rk817->mute;
-
-	return 0;
-}
-
-static int rk817_set_put(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk817_codec_priv *rk817 = snd_soc_component_get_drvdata(component);
-
-/*	if (rk817->mute == ucontrol->value.integer.value[0]) {
-		DBG("%s : mute is not changed!\n",
-		    __func__);
-		return 0;
-	}
-*/
-	return rk817_mute_config(component, rk817->mute,
-					 ucontrol->value.integer.value[0]);
-}
-
-
-
 static struct snd_kcontrol_new rk817_snd_path_controls[] = {
 	SOC_ENUM_EXT("Playback Path", rk817_playback_path_type,
 		     rk817_playback_path_get, rk817_playback_path_put),
 
 	SOC_ENUM_EXT("Capture MIC Path", rk817_capture_path_type,
 		     rk817_capture_path_get, rk817_capture_path_put),
-			 
-	SOC_ENUM_EXT("MUTE", rk817_mute_type,
-		     rk817_mute_get, rk817_set_put),		 
 };
 
 static int rk817_set_dai_sysclk(struct snd_soc_dai *codec_dai,
@@ -978,12 +905,14 @@ static int rk817_hw_params(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct rk817_codec_priv *rk817 = snd_soc_component_get_drvdata(component);
 	unsigned int rate = params_rate(params);
 	unsigned char apll_cfg3_val;
 	unsigned char dtop_digen_sr_lmt0;
 	unsigned char dtop_digen_clke;
 
-	DBG("%s : sample rate = %dHz\n", __func__, rate);
+	DBG("%s : MCLK = %dHz, sample rate = %dHz\n",
+	    __func__, rk817->stereo_sysclk, rate);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		dtop_digen_clke = DAC_DIG_CLK_EN;
@@ -1049,6 +978,44 @@ static int rk817_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+#if defined(CONFIG_RK817_HEADSET)
+/*
+ * Call from rk_headset_irq_hook_adc.c
+ *
+ * Enable micbias for HOOK detection and disable external Amplifier
+ * when jack insertion.
+ */
+
+int rk817_hp_inserted=0;
+#ifdef __MURMUR__
+EXPORT_SYMBOL(rk817_hp_inserted);
+#endif
+int rk817_headset_detect(int jack_insert)
+{
+	struct rk817_codec_priv *rk817;
+	
+	rk817_hp_inserted=jack_insert;
+
+	if (!rk817_g)
+		return -1;
+
+	rk817=rk817_g;
+	
+	rk817_g->hp_inserted = jack_insert;
+
+	/*enable micbias and disable PA*/
+	if (jack_insert) {		
+		rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+	}else{
+		rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(rk817_headset_detect);
+#endif
+
+
 static int rk817_digital_mute(struct snd_soc_dai *dai, int mute)
 {
 	struct snd_soc_component *component = dai->component;
@@ -1098,10 +1065,18 @@ static int rk817_digital_mute(struct snd_soc_dai *dai, int mute)
 		case HP_NO_MIC:
 		case RING_HP:
 		case RING_HP_NO_MIC:
-			snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
+					snd_soc_component_write(component, RK817_CODEC_ADAC_CFG1,
 					PWD_DACBIAS_ON | PWD_DACD_DOWN |
 					PWD_DACL_ON | PWD_DACR_ON);
+			#if defined(CONFIG_RK817_HEADSET)
+			if (!rk817->hp_inserted){
+				rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
+			}else{
+				rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+			}
+			#else
 			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+			#endif	
 			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
 			break;
 		case SPK_HP:
@@ -1196,6 +1171,10 @@ static int rk817_suspend(struct snd_soc_component *component)
 
 static int rk817_resume(struct snd_soc_component *component)
 {
+	struct rk817_codec_priv *rk817 = snd_soc_component_get_drvdata(component);
+
+	rk817_capture_path_config(component, OFF, rk817->capture_path);
+	rk817_playback_path_config(component, OFF, rk817->playback_path);
 	return 0;
 }
 
@@ -1372,6 +1351,7 @@ static int rk817_platform_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "%s : rk817 is NULL\n", __func__);
 		return -EINVAL;
 	}
+	
 
 	rk817_codec_data = devm_kzalloc(&pdev->dev,
 					sizeof(struct rk817_codec_priv),
@@ -1379,6 +1359,14 @@ static int rk817_platform_probe(struct platform_device *pdev)
 	if (!rk817_codec_data)
 		return -ENOMEM;
 
+	#if defined(CONFIG_RK817_HEADSET)
+	rk817_g	= rk817_codec_data;
+	if(rk817_g->hp_inserted)
+		rk817_g->hp_inserted = true;
+	else
+		rk817_g->hp_inserted = false;
+	#endif
+
 	platform_set_drvdata(pdev, rk817_codec_data);
 
 	ret = rk817_codec_parse_dt_property(&pdev->dev, rk817_codec_data);
@@ -1455,4 +1443,4 @@ module_platform_driver(rk817_codec_driver);
 
 MODULE_DESCRIPTION("ASoC RK817 codec driver");
 MODULE_AUTHOR("binyuan <kevan.lan@rock-chips.com>");
-MODULE_LICENSE("GPL v2");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/sound/soc/codecs/rk817_codec.h b/sound/soc/codecs/rk817_codec.h
index a928c3239..a98b01104 100644
--- a/sound/soc/codecs/rk817_codec.h
+++ b/sound/soc/codecs/rk817_codec.h
@@ -212,4 +212,4 @@ struct rk817_init_bit_typ {
 	unsigned int init_bit;
 };
 
-#endif /* __RK817_CODEC_H__ */
+#endif /* __RK817_CODEC_H__ */
\ No newline at end of file